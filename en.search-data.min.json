[{"id":0,"href":"/dit7/gemma/02basics/circuitPython/","title":"CircuitPython","parent":"Learning the basics","content":"Let\u0026rsquo;s get something happening on your Gemma.\nAll of these examples are complete programs, so make sure you copy them into Mu (or whatever editor you\u0026rsquo;re using) and run them as you go through this page.\n Flash the built-in LED Flash the built-in RGB LED Respond to the capacitive input Capacitive input and the RGB LED   Flash the built-in LED    The first thing you try to get working on any embedded system is flashing a light. It\u0026rsquo;s amazing how much information you can convey with just a light if you get a little creative!\n1 2 3 4 5 6 7 8 9 10 11 12 13  import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT while True: led.value = True time.sleep(0.5) led.value = False time.sleep(0.5)   Lines 1-3 import various libraries that we will use. All of your Gemma programs will start with one or more of these import lines.\nLine 5 gives us a reference to the pin that the built-in LED (the red one) is connected to. We store that reference in a variable called led. Line 6 tells the Gemma that we want to use the pin we\u0026rsquo;ve called led as an output (to drive the red LED).\nLines 8-12 are an infinite loop. We turn the LED on, wait for half a second, turn it off, and wait another half second. Then we do it all again, and again, and so on.\nCheck your units\nNote that time.sleep() takes values in seconds, rather than milliseconds.\n If you\u0026rsquo;ve written this in Mu, it should look like this:\nFlash the built-in RGB LED    Now we\u0026rsquo;ve got something happening, let\u0026rsquo;s explore the built-in RGB LED. This model of LED is a Dotstar. The LEDs on the strip we\u0026rsquo;ll be using are a model called Neopixel.\n1 2 3 4 5 6 7 8 9 10 11  import board import adafruit_dotstar as dotstar import time dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: dot[0] = (255, 255, 0) time.sleep(0.5) dot[0] = (0, 0, 255) time.sleep(0.5)   Notice that we on line 5 we call the dotstar dot, but to use it we say dot[0]. Dotstars and Neopixels are designed to be chained together on a strip with common wires, so dot actually refers to a list of LEDs, not just one. Counting in computers usually begins at zero, so the LED at the end closest to the signal source is numbered dot[0] and the others numbered dot[1], dot[2] and so on. Since there is only one built-in dotstar, we only use dot[0].\nRespond to the capacitive input    You can use pin A2 as a capacitive input, meaning it will detect your finger touching it.\n1 2 3 4 5 6 7 8 9 10 11  import board import digitalio from touchio import TouchIn touch2 = TouchIn(board.A2) led = digitalio.DigitalInOut(board.D13) led.direction = digitalio.Direction.OUTPUT while True: led.value = touch2.value   Capacitive input and the RGB LED    If we want to control the RGB led with with the touch input, we need to do a bit more work, and use an if statement.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import board import adafruit_dotstar as dotstar from touchio import TouchIn touch2 = TouchIn(board.A2) dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: if touch2.value: dot[0] = (255, 255, 0) else: dot[0] = (0, 0, 255)   "},{"id":1,"href":"/dit7/gemma/01gettingStarted/","title":"Getting started","parent":"Gemma","content":""},{"id":2,"href":"/dit7/microbit/","title":"Microbit","parent":"7 Digital Tech","content":""},{"id":3,"href":"/dit7/gemma/02basics/counters/","title":"Counters","parent":"Learning the basics","content":"Embedded code like on a Gemma or Micro:bit often involves going around a main loop forever. We can\u0026rsquo;t use sleep/wait/delay functions because they\u0026rsquo;ll stop everything else from happening. We can use counters to make multiple actions seem to happen at once.\nHere is an example. In this case, you can see in the flowchart below that we will use a counter called n, and initialise it to 0. Each time around the loop we will check if n has reached 1000 yet. If it has we will reset it to 0. Otherwise, it will increment n (add 1 to it).\n  flowchart LR a([Start]) b[Set n = 0] c[Switch light off] d{n == 1000?} e[Set n = 0] f[Flick switch] g[Increment n] a--b--c--d d--True--e--f--d d--False--g--d  Here is the equivalent Python code to run on your Gemma. Note that this loop goes around 1000 times before it flicks the switch each time. Observe how fast the light is flashing; remember that computers are really, really, really, really fast!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT n = 0 led.value = False while True: if n == 1000: n = 0 led.value = not led.value n += 1   A wild example    Here is a crazier example with four counters, one each for the built-in led, and each of the red, green and blue channels of the dotstar.\nEach counter is reset and its respective switch \u0026ldquo;flicked\u0026rdquo; after a given amount of time. Try changing the counter values to make different patterns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import board import digitalio import adafruit_dotstar as dotstar led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) ledCount = 0 led.value = False redCount = 0 redValue = 0 greenCount = 0 greenValue = 0 blueCount = 0 blueValue = 0 while True: if ledCount == 500: ledCount = 0 led.value = not led.value if redCount == 700: redCount = 0 redValue = 255 - redValue if greenCount == 900: greenCount = 0 greenValue = 255 - greenValue if blueCount == 1100: blueCount = 0 blueValue = 255 - blueValue ledCount += 1 redCount += 1 greenCount += 1 blueCount += 1 dot[0] = (redValue, greenValue, blueValue)   "},{"id":4,"href":"/dit7/gemma/02basics/","title":"Learning the basics","parent":"Gemma","content":""},{"id":5,"href":"/dit7/gemma/","title":"Gemma","parent":"7 Digital Tech","content":""},{"id":6,"href":"/dit7/glossary/","title":"Glossary","parent":"7 Digital Tech","content":""},{"id":7,"href":"/dit7/troubleshooting/","title":"Troubleshooting","parent":"7 Digital Tech","content":""},{"id":8,"href":"/dit7/reference/","title":"Reference materials","parent":"7 Digital Tech","content":" Adafruit Gemma M0 site CircuitPython Firmware for Gemma M0 CircuitPython Libraries  TMC required library files v7 library files    "},{"id":9,"href":"/dit7/teaching/","title":"Teaching materials","parent":"7 Digital Tech","content":""},{"id":10,"href":"/dit7/gemma/projectIdeas/bikeLight/","title":"Bike Light","parent":"Project ideas","content":""},{"id":11,"href":"/dit7/","title":"7 Digital Tech","parent":"","content":"Welcome to Year 7 Digital Technology!\n"},{"id":12,"href":"/dit7/microbit/tasks/","title":"Activity 1 - Algorithms and Coding","parent":"Microbit","content":"You will need to submit your code for each activity to the hand-in system (only accessible from the school network).\n Sequencing   Activity 1.1 Activity 1.2 Activity 1.3 Activity 1.4  Variables and Lists   Activity 2.1 Activity 2.2 Activity 2.3 Activity 2.4 Activity 2.5  Iteration and Selection   Activity 3.1 Activity 3.2 Activity 3.3 Activity 3.4  Accelerometer   Activity 4.1 Activity 4.2 Activity 4.3 Activity 4.4 Extension  Music   Activity 5.1 Activity 5.2 Activity 5.3 Extension  Networking   Activity 6.1 Activity 6.2 Activity 6.3 Activity 6.4 Extension  "},{"id":13,"href":"/dit7/glossary/argument/","title":"argument","parent":"Glossary","content":"When calling a function, the values given to it are called arguments. For example, in this case:\ntotal = add(3, 4) 3 and 4 are arguments to the function add().\nWhen defining a function, the pieces of information that the function takes to do its job are called parameters.\n"},{"id":14,"href":"/dit7/categories/","title":"Categories","parent":"7 Digital Tech","content":""},{"id":15,"href":"/dit7/glossary/color/","title":"color/colour","parent":"Glossary","content":"In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.\nColors are slightly different on the Gemma from most other programming environments. For most programming, colors are described by the amount of red, green, and blue light to emit. These numbers are normally in the range 0 to 255. In Python, we list these as a tuple (red, green, blue), such as:\n(0, 150, 255) The built-in RGB LED on your Gemma (a Dotstar) has these three color components, so we set its color in this way.\nThe Neopixel RGB LEDs you will solder onto your Gemma have four components: the usual red, green, and blue and also white. So you if you wanted the above color on your Neopixel LED strip, you would use:\n(0, 150, 255, 0) Unless you want to set a particular LED pixel to be white in color, it is recommended that you set the white value to zero (0), as the white tends to wash out the colors otherwise.\nYou can use the Google Color Picker to find different colors, and then copy the RGB value listed. Don\u0026rsquo;t forget to add a value for the white (probably zero) after the other three numbers, if you are setting Neopixel colors.\n"},{"id":16,"href":"/dit7/gemma/projectIdeas/cyclingColours/","title":"Cycling colours","parent":"Project ideas","content":"import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # Named colours RED = (255, 0 , 0, 0) BLUE = (0, 0, 255, 0) GREEN = (0, 255, 0, 0) OFF = (0, 0, 0, 0) # List of colours to cycle through colours = [RED, GREEN, BLUE, (255,0,255)] # Index of which colour in the list we\u0026#39;re on coloursIndex = 0 # Timer for when to print the vibration sensor value printTimer = 0 # Timer to make sure that we wait # for one vibration to have stopped # before we check for the next debounce = 0 # Timer for changing colours if we\u0026#39;re on colourTimer = 0 # Whether the light is on or not on = False # Turn lights off to start pixels.fill((0,0,0,0)) while True: dotstar[0] = (0,0,printTimer) vibration = get_voltage(vibrationPin) # Check the timers and reset them if they\u0026#39;ve gone off if printTimer == 0: printTimer = 255 print(vibration) if colourTimer == 0: colourTimer = 255 coloursIndex = (coloursIndex + 1)%len(colours) if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) if debounce == 0 and vibration \u0026lt; 0.8: debounce = 255 print(vibration) on = not on if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) printTimer -= 1 colourTimer -= 1 debounce -= 1 if debounce \u0026lt; 0: debounce = 0 "},{"id":17,"href":"/dit7/handin/","title":"Hand-in","parent":"7 Digital Tech","content":"Hand in assignments\n"},{"id":18,"href":"/dit7/glossary/import/","title":"import","parent":"Glossary","content":"Importing is the process of adding functions from additional libraries to support your program.\nImagine we wish to use the randint() function to choose a random number between 1 and 6, as though we were throwing a single six-sided die.\nThe randint() function is included in the random library, but there are three ways we can import it, and each has its attractions.\nimport    1 2 3 4  import random num = random.randint(1,6) print(num)   import as    1 2 3 4  import random as ran num = ran.randint(1,6) print(num)   import from    1 2 3 4  from random import randint num = randint(1,6) print(num)   "},{"id":19,"href":"/dit7/glossary/list/","title":"list","parent":"Glossary","content":"A list is a data structure for storing a series of related pieces of information.\n Defining a list Selecting elements Adding elements Removing elements   Defining a list    You can define a list using square brackets, with the elements separated by commas, like this:\nsquares = [0, 1, 4, 9, 16, 25, 36] vowels = [\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;] Selecting elements    You can pick an element from the list like this: squares[0]. Note that counting begins at zero. Think of the number as \u0026ldquo;how far from the beginning\u0026rdquo; the element in the list is. So vowels[0] is the element at the start of the list, and vowels[3] is three elements further down the list. So the string \u0026quot;u\u0026quot; in that list would be vowels[4].\nAdding elements    You can add elements to the end of a list with the append() function.\nsquares.append(49) print(squares[7]) # Output: 49 Removing elements    You can remove elements from a list with remove() and pop().\nfriends = [\u0026#34;Nhi\u0026#34;, \u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] friends.remove(\u0026#34;David\u0026#34;) print(friends) # Output: [\u0026#34;Nhi, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] If there are multiple elements in the list with the same value, remove() will remove just the first one.\nfriends = [\u0026#34;Nhi\u0026#34;, \u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] exBestie = friends.pop(0) print(friends) # Output: [\u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] print(exBestie) # Output: \u0026#34;Nhi\u0026#34; "},{"id":20,"href":"/dit7/gemma/projectIdeas/onOffLamp/","title":"On-off lamp","parent":"Project ideas","content":"This example shows the basics of a state machine, also known by the more technical term finite state automaton. The idea is that the program is in a particular state, and certain events will cause a transition to another state.\nIn our case, our light is either on or off (the states), and we will transition between them with a big enough vibration reading. Here is a state diagram of this:\n  stateDiagram-v2 direction LR [*] -- Off Off -- On : if vibration Off : if vibration Note the \u0026ldquo;and ready\u0026rdquo; condition. Given how fast the computer is, when we tap the light, the vibration value will be less than 0.80 for many cycles of the event loop, and without some care our light will flash on and off rapidly, and be unpredictable.\nHere is the complete code with several comments included. We\u0026rsquo;ll break it down below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  # Import libraries import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board # Set up neopixel light strip pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) # Built-in RGB light dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # A list of all the states, each uniquely numbered # (not important what the numbers are, # as long as they\u0026#39;re unique) OFF = 0 ON = 1 # Variable to keep track of which state we\u0026#39;re in. state = OFF # Flag to keep track of whether we\u0026#39;re \u0026#34;ready\u0026#34; or not ready = True # Counter to keep track of when the ready flag should be set readyCounter = 0 # Counter to print vibration value printCounter = 0 # Event loop while True: vibration = get_voltage(vibrationPin) # Do code matching the current state, whether OFF or ON if state == OFF: # ensure light off pixels.fill((0, 0, 0, 0)) # check for events which cause transition from this state if vibration \u0026lt; 0.8 and ready: # do anything we need to exit this state # change state for next iteration of the loop state = ON # do anything we need to enter new state # Make us not ready, and set the ready counter ready = False readyCounter = 100 elif state == ON: # ensure light on pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 0, 0) pixels[2] = (0, 0, 255, 0) # check for events if vibration \u0026lt; 0.8 and ready: state = OFF ready = False readyCounter = 100 # Handle the counters if readyCounter \u0026gt; 0: # Decrement the counter readyCounter -= 1 # If zero, we\u0026#39;re \u0026#34;ready\u0026#34; if readyCounter == 0: ready = True if printCounter == 0: print(state, ready, vibration) printCounter = (printCounter + 1) % 10   "},{"id":21,"href":"/dit7/glossary/parameter/","title":"parameter","parent":"Glossary","content":"When defining a function, the pieces of information that the function takes to do its job are called parameters. For example, here:\ndef add(first, second): return first + second first and second are the parameters of the function add().\nWhen calling a function, the values given to it are called arguments.\n"},{"id":22,"href":"/dit7/gemma/projectIdeas/","title":"Project ideas","parent":"Gemma","content":""},{"id":23,"href":"/dit7/teaching/siteUrl/","title":"Site URL 🡄🡆","parent":"Teaching materials","content":"Learn about your Gemma here:\nhttps://tmcdigitech.github.io/gemma/\n"},{"id":24,"href":"/dit7/gemma/01gettingStarted/installation/","title":"Software","parent":"Getting started","content":"To program you Gemma M0 or other CircuitPython compatible hardware, you will need to either:\n use Mu, or use another editor  Mu is set up to be very helpful for beginners. It has some keyboard shortcuts, good help text, nice shortcut buttons, and is generally very friendly to use and has a lot of features to help beginners get started. It also includes a Serial Monitor, meaning Mu will automatically display information sent back from your Gemma.\nAfter you have been writing code for a while, you may find that a more powerful text editor like Visual Studio Code allows you a lot more power and flexibility, at the cost of complexity, and possibly doing some more basic things yourself.\nUsing Mu    Install Mu, using the Company Portal (on a school computer), or from the website.\nTo program your Gemma M0, make sure you select the mode CircuitPython (depending on your version, it may be called something slightly different, but it is the mode with \u0026lsquo;CircuitPython\u0026rsquo; somewhere in the title).\nUsing Visual Studio Code    Install Visual Studio Code from the Company Portal (on a school computer), or from the website.\n"},{"id":25,"href":"/dit7/gemma/01gettingStarted/fileStructure/","title":"Structuring your files","parent":"Getting started","content":"When you plug your Gemma in to your computer, it will appear as a USB drive (probably D:, unless you\u0026rsquo;ve got something else already plugged in). If you open the Gemma, you\u0026rsquo;ll see a file called code.py or main.py. This is the file that your Gemma will run. To change the program your Gemma is running, just edit this file!\nD:/ ├── code.py # on newer versions ├── main.py # on older versions │ └── lib/ └── ... # library files, which tell the software how to control hardware we might connect "},{"id":26,"href":"/dit7/tags/","title":"Tags","parent":"7 Digital Tech","content":""},{"id":27,"href":"/dit7/glossary/tuple/","title":"tuple","parent":"Glossary","content":"A tuple is a single unit of data made up of multiple values. In Python they are defined using round brackets, with commas separating the values. Tuples can contain all sorts of data as values, but when programming Gemma we mostly use them for colors (red, green, blue, white).\n"},{"id":28,"href":"/dit7/glossary/type/","title":"type","parent":"Glossary","content":"Computers store all information as sequences of numbers, but different kinds of data are encoded in different ways. For example, whole numbers and decimal numbers are stored differently.\nSome common data types you\u0026rsquo;ll encounter are:\n integers (int) Integers are whole numbers, and can be positive or negative. floating point numbers (float and double) Floating point numbers (commonly called floats) are for storing decimal numbers. The number is stored in scientific notation, with a mantissa and exponent.    \\[\\overbrace{3.18}^{\\text{mantissa}}\\times 10^{\\overbrace{-7}^{\\text{exponent}}}\\]  There is a limited number of digits for the mantissa and the exponent. If you need more, a double precision floating point number (or double for short) has twice the space, so can store a more precise mantissa, and a larger exponent. characters (char) A character is a single letter, digit, punctuation mark, or piece of whitespace (a space, newline, tab, etc.). strings (string) Strings are so called because they are \u0026lsquo;strings of characters\u0026rsquo;. They are usually indicated with double quotes \u0026ldquo;like this\u0026rdquo;. In some languages, like Python, strings can be in single quotes as well, \u0026lsquo;like this\u0026rsquo;.  "},{"id":29,"href":"/dit7/glossary/variable/","title":"variable","parent":"Glossary","content":"A variable is a named place to store a piece of information.\n"},{"id":30,"href":"/dit7/troubleshooting/01whybroken/","title":"Why won't my program work?","parent":"Troubleshooting","content":"Here is a checklist of things to look for if something is wrong\u0026hellip;\nSpelling and Capitalisation    Remember that the computer is really, really, really, really stupid. It will recognise only words it has been taught; it is not clever enough to handle spelling mistakes - these will confuse it. It is also not clever enough to know that most of the time we use A and a interchangeably, so you have to make sure that if the computer is expecting a capital letter, you give it one, and vice versa.\n"}]