[{"id":0,"href":"/dit7/relief/","title":"RELIEF LESSON","parent":"7 Digital Tech","content":"Monday T2.9 (4 July)\nHi all. Today is a chance for you to show off your teamwork skills. Work your way through the Activities in Task 1 on your Microbit. If you get stuck, or things are not working, see if the people around you can help. The most likely problem you\u0026rsquo;ll make is spelling a word wrong, getting your capitals and lowercase letters mixed up, or using the wrong piece of punctuation.\nIf you get really stuck, you can email me.\n"},{"id":1,"href":"/dit7/gemma/03basics/circuitPython/","title":"CircuitPython","parent":"Learning the basics","content":"Let\u0026rsquo;s get something happening on your Gemma.\nAll of these examples are complete programs, so make sure you copy them into Mu (or whatever editor you\u0026rsquo;re using) and run them as you go through this page.\nFlash the built-in LED Flash the built-in RGB LED Respond to the capacitive input Capacitive input and the RGB LED Flash the built-in LED The first thing you try to get working on any embedded system is flashing a light. It\u0026rsquo;s amazing how much information you can convey with just a light if you get a little creative!\n1 2 3 4 5 6 7 8 9 10 11 12 import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT while True: led.value = True time.sleep(0.5) led.value = False time.sleep(0.5) Lines 1-3 import various libraries that we will use. All of your Gemma programs will start with one or more of these import lines.\nLine 5 gives us a reference to the pin that the built-in LED (the red one) is connected to. We store that reference in a variable called led. Line 6 tells the Gemma that we want to use the pin we\u0026rsquo;ve called led as an output (to drive the red LED).\nLines 8-12 are an infinite loop. We turn the LED on, wait for half a second, turn it off, and wait another half second. Then we do it all again, and again, and so on.\nCheck your units\nNote that time.sleep() takes values in seconds, rather than milliseconds.\nIf you\u0026rsquo;ve written this in Mu, it should look like this:\nFlash the built-in RGB LED Now we\u0026rsquo;ve got something happening, let\u0026rsquo;s explore the built-in RGB LED. This model of LED is a Dotstar. The LEDs on the strip we\u0026rsquo;ll be using are a model called Neopixel.\n1 2 3 4 5 6 7 8 9 10 11 import board import adafruit_dotstar as dotstar import time dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: dot[0] = (255, 255, 0) time.sleep(0.5) dot[0] = (0, 0, 255) time.sleep(0.5) Notice that we on line 5 we call the dotstar dot, but to use it we say dot[0]. Dotstars and Neopixels are designed to be chained together on a strip with common wires, so dot actually refers to a list of LEDs, not just one. Counting in computers usually begins at zero, so the LED at the end closest to the signal source is numbered dot[0] and the others numbered dot[1], dot[2] and so on. Since there is only one built-in dotstar, we only use dot[0].\nRespond to the capacitive input You can use pin A2 as a capacitive input, meaning it will detect your finger touching it.\n1 2 3 4 5 6 7 8 9 10 11 import board import digitalio from touchio import TouchIn touch2 = TouchIn(board.A2) led = digitalio.DigitalInOut(board.D13) led.direction = digitalio.Direction.OUTPUT while True: led.value = touch2.value Capacitive input and the RGB LED If we want to control the RGB led with with the touch input, we need to do a bit more work, and use an if statement.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import board import adafruit_dotstar as dotstar from touchio import TouchIn touch2 = TouchIn(board.A2) dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: if touch2.value: dot[0] = (255, 255, 0) else: dot[0] = (0, 0, 255) "},{"id":2,"href":"/dit7/microbit/","title":"Microbit","parent":"7 Digital Tech","content":""},{"id":3,"href":"/dit7/microbit/tasks/","title":"Task 1 - Algorithms and Coding","parent":"Microbit","content":"You will need to submit your code for each activity to the hand-in system (only accessible from the school network).\nSequencing\nActivity 1.1, 1.2, 1.3, 1.4\nVariables and Lists\nActivity 2.1, 2.3, 2.2, 2.4, 2.5\nImage design template\nIteration and Selection\nActivity 3.1, 3.2, 3.3, 3.4\nAccelerometer\nActivity 4.1, 4.2, 4.3, 4.4, Extension\nMusic\nActivity 5.1, 5.2, 5.3, Extension\nNetworking\nActivity 6.1, 6.2, 6.3, 6.4, Extension\nWorking at home?\nTry the Microbit simulator at create.withcode.uk. Type your code in as usual (including the all important from microbit import * line), and then press the big play (▶) button in the bottom right to run it.\n"},{"id":4,"href":"/dit7/gemma/03basics/counters/","title":"Counters","parent":"Learning the basics","content":"Embedded code like on a Gemma or Micro:bit often involves going around a main loop forever. We can\u0026rsquo;t use sleep/wait/delay functions because they\u0026rsquo;ll stop everything else from happening. We can use counters to make multiple actions seem to happen at once.\nHere is an example. In this case, you can see in the flowchart below that we will use a counter called n, and initialise it to 0. Each time around the loop we will check if n has reached 1000 yet. If it has we will reset it to 0. Otherwise, it will increment n (add 1 to it).\nflowchart LR a([Start]) b[Set n = 0] c[Switch light off] d{n == 1000?} e[Set n = 0] f[Flick switch] g[Increment n] a--\u003eb--\u003ec--\u003ed d--True--\u003ee--\u003ef--\u003ed d--False--\u003eg--\u003ed Here is the equivalent Python code to run on your Gemma. Note that this loop goes around 1000 times before it flicks the switch each time. Observe how fast the light is flashing; remember that computers are really, really, really, really fast!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT n = 0 led.value = False while True: if n == 1000: n = 0 led.value = not led.value n += 1 A wild example Here is a crazier example with four counters, one each for the built-in led, and each of the red, green and blue channels of the dotstar.\nEach counter is reset and its respective switch \u0026ldquo;flicked\u0026rdquo; after a given amount of time. Try changing the counter values to make different patterns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import board import digitalio import adafruit_dotstar as dotstar led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) ledCount = 0 led.value = False redCount = 0 redValue = 0 greenCount = 0 greenValue = 0 blueCount = 0 blueValue = 0 while True: if ledCount == 500: ledCount = 0 led.value = not led.value if redCount == 700: redCount = 0 redValue = 255 - redValue if greenCount == 900: greenCount = 0 greenValue = 255 - greenValue if blueCount == 1100: blueCount = 0 blueValue = 255 - blueValue ledCount += 1 redCount += 1 greenCount += 1 blueCount += 1 dot[0] = (redValue, greenValue, blueValue) "},{"id":5,"href":"/dit7/microbit/magic8ball/","title":"Task 3 - Magic 8-ball","parent":"Microbit","content":"Using the Microbit, make a Magic 8-ball by following steps 1-5 below.\nEnsure your app is working by carrying out testing and modifying your code. Include comments in your code and hand it in when finished.\nThe Magic 8-ball is a fortune telling toy created by Mattel in the 1950s. The concept is simple. Ask the 8-ball a yes or no question and the 8-ball will reply with answers such as “Yes”, “No”, “Without a doubt” etc. (seemingly able to predict the future). The Magic 8 Ball is made up of 20 responses — 10 positive, 5 negative and 5 neutral. The 20 answers are:\nPositive answers\nIt is certain It is decidedly so Without a doubt Yes definitely You may rely on it As I see it, yes Most likely Outlook good Yes Signs point to yes Negative answers\nDon\u0026rsquo;t count on it My reply is no My sources say no Outlook not so good Very doubtful Neutral answers\nReply hazy, try again Ask again later Better not tell you now Cannot predict now Concentrate and ask again According to Wikipedia \u0026ldquo;Using the coupon collector\u0026rsquo;s problem in probability theory, it can be shown that it takes, on average, 72 outcomes of the Magic 8 Ball for all 20 of its answers to appear at least once.\u0026rdquo;\n1: Write an ‘8’ to the screen In the Microbit app, write the following code:\nfrom microbit import * import random while True: sleep(1000) display.show(\u0026#34;8\u0026#34;) Upload the code to the Microbit and run it. What happens when you shake the Microbit?\n2: Shake it! Add the following code to what you have already written, inside the while True:.\nif accelerometer.was_gesture(\u0026#34;shake\u0026#34;): display.clear() sleep(1000) display.show(\u0026#34;!\u0026#34;) Upload the code to the Microbit and run it. What happens when you shake the Microbit?\n3: Write some responses We need to list our responses, and in Python we do that in a list variable. The list is Python\u0026rsquo;s equivalent to other languages\u0026rsquo; array. Write this code before the while True:.\nanswers = [\u0026#34;Yes\u0026#34;, \u0026#34;No\u0026#34;, \u0026#34;Maybe\u0026#34;, \u0026#34;Yes, definitely\u0026#34;] 4: Pick a random response To make the Magic 8-Ball pick a random response, we can get it to pick a random answer using random.choice().\nsleep(1000) display.scroll(random.choice(answers)) Include this code so that when you shake the Microbit, the microbit will wait a second and then show a random answer to the question you put to it.\n5: Modify and extend your code Modify your list to contain all 20 official responses.\nAdd comments to your code to explain how it works.\nModify your code so that it plays a sound when it gives a response.\nModify your code so that it counts how many responses and shows an image after 3 responses.\n"},{"id":6,"href":"/dit7/microbit/extras/","title":"Other things to try","parent":"Microbit","content":" Light sensor from microbit.org\nfrom microbit import * while True: if display.read_light_level() \u0026gt; 100: display.show(Image( \u0026#34;90909:\u0026#34; \u0026#34;09990:\u0026#34; \u0026#34;99999:\u0026#34; \u0026#34;09990:\u0026#34; \u0026#34;90909\u0026#34;)) else: display.clear() Max/min temperature recorder *from microbit.org\nfrom microbit import * currentTemp = temperature() max = currentTemp min = currentTemp while True: display.show(\u0026#39;.\u0026#39;) currentTemp = temperature() if currentTemp \u0026lt; min: min = currentTemp if currentTemp \u0026gt; max: max = currentTemp if button_a.was_pressed(): display.scroll(min) if button_b.was_pressed(): display.scroll(max) sleep(1000) display.clear() sleep(1000) Teleporting duck from microbit.org\nNote: The radio group is a number between 0 and 255. Microbits set to the same group can send and receive messages. Microbits set to different groups can\u0026rsquo;t share messages. In this example the group is set to 23, but you should change this value if someone else is using channel 23.\nfrom microbit import * import radio radio.config(group=23) radio.on() while True: message = radio.receive() if message: display.show(Image.DUCK) if accelerometer.was_gesture(\u0026#39;shake\u0026#39;): display.clear() radio.send(\u0026#39;duck\u0026#39;) Compass For detecting strong magnetic fields, like those from a magnet you might use to stick something to the fridge, you do not need to calibrate the magnetometer (compass sensor). You do need to calibrate it to detect the relatively small magnetic field of the earth. The microbit will ask you to tilt it until all the display leds are lit.\nfrom microbit import * compass.calibrate() while True: bearing = compass.heading() if bearing \u0026lt; 45 or bearing \u0026gt; 315: display.show(\u0026#39;N\u0026#39;) else: display.show(\u0026#39; \u0026#39;) "},{"id":7,"href":"/dit7/gemma/","title":"Gemma","parent":"7 Digital Tech","content":""},{"id":8,"href":"/dit7/gemma/02examples/flash/","title":"Flash a light","parent":"Examples","content":"The first project you do with any new piece of hardware: flash a light.\nfrom digitalio import DigitalInOut, Direction import board import time # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT while True: led.value = True time.sleep(0.5) led.value = False time.sleep(0.5) "},{"id":9,"href":"/dit7/gemma/01gettingStarted/","title":"Getting started","parent":"Gemma","content":""},{"id":10,"href":"/dit7/gemma/02examples/","title":"Examples","parent":"Gemma","content":""},{"id":11,"href":"/dit7/gemma/02examples/respond/","title":"Respond to input","parent":"Examples","content":"In this example, the light will turn on while you touch pin A2.\nfrom digitalio import DigitalInOut, Direction from touchio import TouchIn import board import time # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Capacitive touch on A2 touch2 = TouchIn(board.A2) while True: led.value = touch2.value "},{"id":12,"href":"/dit7/gemma/02examples/color/","title":"A flash of colo(u)r","parent":"Examples","content":"The Gemma has a built-in (DotStar) RGB LED. DotStar LEDs can be chained together, and even though there is only one on the Gemma, we still refer to it as though it were on a chain, just a chain of one. Colors are set with an RGB tuple. The brightness can be configured between 0 and 1. Why would you want to lower the brightness? Here are three reasons:\nmaximum brightness is almost painfully bright, which is bad if you\u0026rsquo;re up close. at night, a little light goes a long way, and you may not need a simple notification to double as a torch. the brighter it is, the more power it draws, which is a problem for battery powered projects where you want to maximise battery life. import adafruit_dotstar as dotstar import board import time # Configure the DotStar LED, and call it \u0026#34;dot\u0026#34; dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: dot[0] = (255, 0, 0) time.sleep(0.5) dot[0] = (0, 255, 0) time.sleep(0.5) dot[0] = (0, 0, 255) time.sleep(0.5) "},{"id":13,"href":"/dit7/gemma/03basics/","title":"Learning the basics","parent":"Gemma","content":""},{"id":14,"href":"/dit7/gemma/02examples/colorWheel/","title":"Color cycling","parent":"Examples","content":"The demo program that comes with the Gemma includes a nice function which generates a swirl through the rainbow. It takes a number from 0-255 and returns a color as a list (which you can use directly instead of specific color tuple).\n# Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos \u0026lt; 0: return [0, 0, 0] if pos \u0026gt; 255: return [0, 0, 0] if pos \u0026lt; 85: return [int(255 - pos*3), int(pos*3), 0] elif pos \u0026lt; 170: pos -= 85 return [0, int(255 - (pos*3)), int(pos * 3)] else: pos -= 170 return [int(pos*3), 0, int(255 - pos*3)] Here is a complete example of it in action, using the built-in DotStar.\nimport adafruit_dotstar as dotstar import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos \u0026lt; 0: return [0, 0, 0] if pos \u0026gt; 255: return [0, 0, 0] if pos \u0026lt; 85: return [int(255 - pos*3), int(pos*3), 0] elif pos \u0026lt; 170: pos -= 85 return [0, int(255 - (pos*3)), int(pos * 3)] else: pos -= 170 return [int(pos*3), 0, int(255 - pos*3)] color = 0 t = 0 while True: dot[0] = wheel(color) t +=1 if t == 10: t = 0 color += 1 if color == 256: color = 0 "},{"id":15,"href":"/dit7/gemma/02examples/touchKeyboard/","title":"Touch keyboard","parent":"Examples","content":"# Welcome to CircuitPython 5 :) import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode from touchio import TouchIn import board import time # Capacitive touch on A2 touch0 = TouchIn(board.A0) touch1 = TouchIn(board.A1) touch2 = TouchIn(board.A2) # The keyboard object! Used if we do HID output, see below time.sleep(1) # Sleep for a bit to avoid a race condition on some systems keyboard = Keyboard(usb_hid.devices) layout = KeyboardLayoutUS(keyboard) # We\u0026#39;re in the US :) ######################### MAIN LOOP ############################## while True: if touch0.value: keyboard.send(Keycode.CTRL, Keycode.N) keyboard.send(Keycode.CTRL, Keycode.A) layout.write(\u0026#34;This is my computer now...\u0026#34;) time.sleep(1) keyboard.send(Keycode.WINDOWS, Keycode.L) if touch1.value: keyboard.send(Keycode.F11) if touch2.value: keyboard.send(Keycode.NINE) "},{"id":16,"href":"/dit7/glossary/","title":"Glossary","parent":"7 Digital Tech","content":""},{"id":17,"href":"/dit7/gemma/02examples/builtInDemo/","title":"Built-in example","parent":"Examples","content":" 2.2.4 # Gemma IO demo # Welcome to CircuitPython 2.2.4 :) from adafruit_hid.keyboard import Keyboard from adafruit_hid.keycode import Keycode from digitalio import DigitalInOut, Direction, Pull from analogio import AnalogIn, AnalogOut from touchio import TouchIn import adafruit_dotstar as dotstar import microcontroller import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Analog output on A0 aout = AnalogOut(board.A0) # Analog input on A1 analog1in = AnalogIn(board.A1) # Capacitive touch on A2 touch2 = TouchIn(board.A2) # Used if we do HID output, see below kbd = Keyboard() ######################### HELPERS ############################## # Helper to convert analog input to voltage def getVoltage(pin): return (pin.value * 3.3) / 65536 # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u0026lt; 0): return [0, 0, 0] if (pos \u0026gt; 255): return [0, 0, 0] if (pos \u0026lt; 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u0026lt; 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] ######################### MAIN LOOP ############################## i = 0 while True: # spin internal LED around! dot[0] = wheel(i) dot.show() # set analog output to 0-3.3V (0-65535 in increments) aout.value = i * 256 # once every 256 ticks, so it doesnt rush by! if i == 0: # Read analog voltage on A1 print(\u0026#34;A1: %0.2f\u0026#34; % getVoltage(analog1in)) # Print the temperature print(\u0026#34;Temp: %0.1f\u0026#34; % microcontroller.cpu.temperature) # use A2 as capacitive touch to turn on internal LED if touch2.value: print(\u0026#34;A2 touched!\u0026#34;) # optional! uncomment below \u0026amp; save to have it sent a keypress #kbd.press(Keycode.A) #kbd.release_all() led.value = touch2.value i = (i+1) % 256 # run from 0 to 255 5 # Gemma IO demo # Welcome to CircuitPython 5 :) import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode from digitalio import DigitalInOut, Direction, Pull from analogio import AnalogIn, AnalogOut from touchio import TouchIn import adafruit_dotstar as dotstar import microcontroller import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Analog output on A0 aout = AnalogOut(board.A0) # Analog input on A1 analog1in = AnalogIn(board.A1) # Capacitive touch on A2 touch2 = TouchIn(board.A2) # The keyboard object! Used if we do HID output, see below time.sleep(1) # Sleep for a bit to avoid a race condition on some systems keyboard = Keyboard(usb_hid.devices) keyboard_layout = KeyboardLayoutUS(keyboard) # We\u0026#39;re in the US :) ######################### HELPERS ############################## # Helper to convert analog input to voltage def getVoltage(pin): return (pin.value * 3.3) / 65536 # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u0026lt; 0): return [0, 0, 0] if (pos \u0026gt; 255): return [0, 0, 0] if (pos \u0026lt; 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u0026lt; 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] ######################### MAIN LOOP ############################## i = 0 while True: # spin internal LED around! dot[0] = wheel(i) dot.show() # set analog output to 0-3.3V (0-65535 in increments) aout.value = i * 256 # once every 256 ticks, so it doesnt rush by! if i == 0: # Read analog voltage on A1 print(\u0026#34;A1: %0.2f\u0026#34; % getVoltage(analog1in)) # Print the temperature print(\u0026#34;Temp: %0.1f\u0026#34; % microcontroller.cpu.temperature) # use A2 as capacitive touch to turn on internal LED if touch2.value: print(\u0026#34;A2 touched!\u0026#34;) # optional! uncomment below \u0026amp; save to have it sent a keypress #keyboard.press(Keycode.A) #keyboard.release_all() led.value = touch2.value i = (i+1) % 256 # run from 0 to 255 "},{"id":18,"href":"/dit7/troubleshooting/","title":"Troubleshooting","parent":"7 Digital Tech","content":""},{"id":19,"href":"/dit7/reference/","title":"Reference materials","parent":"7 Digital Tech","content":" Adafruit Gemma M0 site CircuitPython Firmware for Gemma M0 CircuitPython Libraries TMC required library files v7 library files "},{"id":20,"href":"/dit7/teaching/","title":"Teaching materials","parent":"7 Digital Tech","content":""},{"id":21,"href":"/dit7/gemma/projectIdeas/bikeLight/","title":"Bike Light","parent":"Project ideas","content":""},{"id":22,"href":"/dit7/","title":"7 Digital Tech","parent":"","content":"Welcome to Year 7 Digital Technology!\n"},{"id":23,"href":"/dit7/glossary/argument/","title":"argument","parent":"Glossary","content":"When calling a function, the values given to it are called arguments. For example, in this case:\ntotal = add(3, 4) 3 and 4 are arguments to the function add().\nWhen defining a function, the pieces of information that the function takes to do its job are called parameters.\n"},{"id":24,"href":"/dit7/categories/","title":"Categories","parent":"7 Digital Tech","content":""},{"id":25,"href":"/dit7/glossary/color/","title":"color/colour","parent":"Glossary","content":"In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.\nColors are described by the amount of red, green, and blue light to emit, using numbers in the range 0 to 255. In Python, we list these as a tuple (red, green, blue), such as:\n(0, 150, 255) The built-in RGB LED on your Gemma (a DotStar) has these three color components, so we set its color in this way.\nThe NeoPixel RGB LEDs you will solder onto your Gemma have four components: the usual red, green, and blue and also white. So you if you wanted the above color on your Neopixel LED strip, you would use:\n(0, 150, 255, 0) Unless you want to set a particular LED pixel to be white in color, it is recommended that you set the white value to zero (0), as the white tends to wash out the colors otherwise.\nYou can use the Google Color Picker to find different colors, and then copy the RGB value listed. Don\u0026rsquo;t forget to add a value for the white (probably zero) after the other three numbers, if you are setting NeoPixel colors.\n"},{"id":26,"href":"/dit7/gemma/projectIdeas/cyclingColours/","title":"Cycling colours","parent":"Project ideas","content":"import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # Named colours RED = (255, 0 , 0, 0) BLUE = (0, 0, 255, 0) GREEN = (0, 255, 0, 0) OFF = (0, 0, 0, 0) # List of colours to cycle through colours = [RED, GREEN, BLUE, (255,0,255)] # Index of which colour in the list we\u0026#39;re on coloursIndex = 0 # Timer for when to print the vibration sensor value printTimer = 0 # Timer to make sure that we wait # for one vibration to have stopped # before we check for the next debounce = 0 # Timer for changing colours if we\u0026#39;re on colourTimer = 0 # Whether the light is on or not on = False # Turn lights off to start pixels.fill((0,0,0,0)) while True: dotstar[0] = (0,0,printTimer) vibration = get_voltage(vibrationPin) # Check the timers and reset them if they\u0026#39;ve gone off if printTimer == 0: printTimer = 255 print(vibration) if colourTimer == 0: colourTimer = 255 coloursIndex = (coloursIndex + 1)%len(colours) if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) if debounce == 0 and vibration \u0026lt; 0.8: debounce = 255 print(vibration) on = not on if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) printTimer -= 1 colourTimer -= 1 debounce -= 1 if debounce \u0026lt; 0: debounce = 0 "},{"id":27,"href":"/dit7/handin/","title":"Hand-in","parent":"7 Digital Tech","content":"Hand in assignments\n"},{"id":28,"href":"/dit7/glossary/import/","title":"import","parent":"Glossary","content":"Importing is the process of adding functions from additional libraries to support your program.\nImagine we wish to use the randint() function to choose a random number between 1 and 6, as though we were throwing a single six-sided die.\nThe randint() function is included in the random library, but there are three ways we can import it, and each has its attractions.\nimport 1 2 3 4 import random num = random.randint(1,6) print(num) import as 1 2 3 4 import random as ran num = ran.randint(1,6) print(num) import from 1 2 3 4 from random import randint num = randint(1,6) print(num) "},{"id":29,"href":"/dit7/glossary/list/","title":"list","parent":"Glossary","content":"A list is a data structure for storing a series of related pieces of information.\nDefining a list Selecting elements Adding elements Removing elements Defining a list You can define a list using square brackets, with the elements separated by commas, like this:\nsquares = [0, 1, 4, 9, 16, 25, 36] vowels = [\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;] Selecting elements You can pick an element from the list like this: squares[0]. Note that counting begins at zero. Think of the number as \u0026ldquo;how far from the beginning\u0026rdquo; the element in the list is. So vowels[0] is the element at the start of the list, and vowels[3] is three elements further down the list. So the string \u0026quot;u\u0026quot; in that list would be vowels[4].\nAdding elements You can add elements to the end of a list with the append() function.\nsquares.append(49) print(squares[7]) # Output: 49 Removing elements You can remove elements from a list with remove() and pop().\nfriends = [\u0026#34;Nhi\u0026#34;, \u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] friends.remove(\u0026#34;David\u0026#34;) print(friends) # Output: [\u0026#34;Nhi, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] If there are multiple elements in the list with the same value, remove() will remove just the first one.\nfriends = [\u0026#34;Nhi\u0026#34;, \u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] exBestie = friends.pop(0) print(friends) # Output: [\u0026#34;David\u0026#34;, \u0026#34;Hari\u0026#34;, \u0026#34;Zahra\u0026#34;] print(exBestie) # Output: \u0026#34;Nhi\u0026#34; "},{"id":30,"href":"/dit7/gemma/projectIdeas/onOffLamp/","title":"On-off lamp","parent":"Project ideas","content":"This example shows the basics of a state machine, also known by the more technical term finite state automaton. The idea is that the program is in a particular state, and certain events will cause a transition to another state.\nIn our case, our light is either on or off (the states), and we will transition between them with a big enough vibration reading. Here is a state diagram of this:\nstateDiagram-v2 direction LR [*] --\u003e Off Off --\u003e On : if vibration \u003c 0.80 and ready On --\u003e Off : if vibration \u003c 0.80 and ready Note the \u0026ldquo;and ready\u0026rdquo; condition. Given how fast the computer is, when we tap the light, the vibration value will be less than 0.80 for many cycles of the event loop, and without some care our light will flash on and off rapidly, and be unpredictable.\nHere is the complete code with several comments included. We\u0026rsquo;ll break it down below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # Import libraries import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board # Set up neopixel light strip pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) # Built-in RGB light dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # A list of all the states, each uniquely numbered # (not important what the numbers are, # as long as they\u0026#39;re unique) OFF = 0 ON = 1 # Variable to keep track of which state we\u0026#39;re in. state = OFF # Flag to keep track of whether we\u0026#39;re \u0026#34;ready\u0026#34; or not ready = True # Counter to keep track of when the ready flag should be set readyCounter = 0 # Counter to print vibration value printCounter = 0 # Event loop while True: vibration = get_voltage(vibrationPin) # Do code matching the current state, whether OFF or ON if state == OFF: # ensure light off pixels.fill((0, 0, 0, 0)) # check for events which cause transition from this state if vibration \u0026lt; 0.8 and ready: # do anything we need to exit this state # change state for next iteration of the loop state = ON # do anything we need to enter new state # Make us not ready, and set the ready counter ready = False readyCounter = 100 elif state == ON: # ensure light on pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 0, 0) pixels[2] = (0, 0, 255, 0) # check for events if vibration \u0026lt; 0.8 and ready: state = OFF ready = False readyCounter = 100 # Handle the counters if readyCounter \u0026gt; 0: # Decrement the counter readyCounter -= 1 # If zero, we\u0026#39;re \u0026#34;ready\u0026#34; if readyCounter == 0: ready = True if printCounter == 0: print(state, ready, vibration) printCounter = (printCounter + 1) % 10 "},{"id":31,"href":"/dit7/glossary/parameter/","title":"parameter","parent":"Glossary","content":"When defining a function, the pieces of information that the function takes to do its job are called parameters. For example, here:\ndef add(first, second): return first + second first and second are the parameters of the function add().\nWhen calling a function, the values given to it are called arguments.\n"},{"id":32,"href":"/dit7/gemma/projectIdeas/","title":"Project ideas","parent":"Gemma","content":""},{"id":33,"href":"/dit7/teaching/siteUrl/","title":"Site URL 🡄🡆","parent":"Teaching materials","content":"https://tmcdigitech.github.io/dit7/\n"},{"id":34,"href":"/dit7/gemma/01gettingStarted/installation/","title":"Software","parent":"Getting started","content":"To program you Gemma M0 or other CircuitPython compatible hardware, you will need to either:\nuse Mu, or use another editor Mu is set up to be very helpful for beginners. It has some keyboard shortcuts, good help text, nice shortcut buttons, and is generally very friendly to use and has a lot of features to help beginners get started. It also includes a Serial Monitor, meaning Mu will automatically display information sent back from your Gemma.\nAfter you have been writing code for a while, you may find that a more powerful text editor like Visual Studio Code allows you a lot more power and flexibility, at the cost of complexity, and possibly doing some more basic things yourself.\nUsing Mu Install Mu, using the Company Portal (on a school computer), or from the website.\nTo program your Gemma M0, make sure you select the mode CircuitPython (depending on your version, it may be called something slightly different, but it is the mode with \u0026lsquo;CircuitPython\u0026rsquo; somewhere in the title).\nUsing Visual Studio Code Install Visual Studio Code from the Company Portal (on a school computer), or from the website.\n"},{"id":35,"href":"/dit7/gemma/01gettingStarted/fileStructure/","title":"Structuring your files","parent":"Getting started","content":"When you plug your Gemma in to your computer, it will appear as a USB drive (probably D:, unless you\u0026rsquo;ve got something else already plugged in). If you open the Gemma, you\u0026rsquo;ll see a file called code.py or main.py. This is the file that your Gemma will run. To change the program your Gemma is running, just edit this file!\nD:/ ├── code.py # on newer versions ├── main.py # on older versions │ └── lib/ └── ... # library files, which tell the software how to control hardware we might connect "},{"id":36,"href":"/dit7/tags/","title":"Tags","parent":"7 Digital Tech","content":""},{"id":37,"href":"/dit7/glossary/tuple/","title":"tuple","parent":"Glossary","content":"A tuple is a single unit of data made up of multiple values. In Python they are defined using round brackets, with commas separating the values. Tuples can contain all sorts of data as values, but when programming Gemma we mostly use them for colors (red, green, blue, white).\n"},{"id":38,"href":"/dit7/glossary/type/","title":"type","parent":"Glossary","content":"Computers store all information as sequences of numbers, but different kinds of data are encoded in different ways. For example, whole numbers and decimal numbers are stored differently.\nSome common data types you\u0026rsquo;ll encounter are:\nintegers (int) Integers are whole numbers, and can be positive or negative. floating point numbers (float and double) Floating point numbers (commonly called floats) are for storing decimal numbers. The number is stored in scientific notation, with a mantissa and exponent. \\[\\overbrace{3.18}^{\\text{mantissa}}\\times 10^{\\overbrace{-7}^{\\text{exponent}}}\\] There is a limited number of digits for the mantissa and the exponent. If you need more, a double precision floating point number (or double for short) has twice the space, so can store a more precise mantissa, and a larger exponent. characters (char) A character is a single letter, digit, punctuation mark, or piece of whitespace (a space, newline, tab, etc.). strings (string) Strings are so called because they are \u0026lsquo;strings of characters\u0026rsquo;. They are usually indicated with double quotes \u0026ldquo;like this\u0026rdquo;. In some languages, like Python, strings can be in single quotes as well, \u0026rsquo;like this\u0026rsquo;. "},{"id":39,"href":"/dit7/glossary/variable/","title":"variable","parent":"Glossary","content":"A variable is a named place to store a piece of information.\n"},{"id":40,"href":"/dit7/troubleshooting/01whybroken/","title":"Why won't my program work?","parent":"Troubleshooting","content":"Here is a checklist of things to look for if something is wrong\u0026hellip;\nSpelling and Capitalisation Remember that the computer is really, really, really, really stupid. It will recognise only words it has been taught; it is not clever enough to handle spelling mistakes - these will confuse it. It is also not clever enough to know that most of the time we use A and a interchangeably, so you have to make sure that if the computer is expecting a capital letter, you give it one, and vice versa.\n"}]